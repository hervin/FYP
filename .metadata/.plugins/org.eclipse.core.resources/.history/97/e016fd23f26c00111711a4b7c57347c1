//============================================================================
// Name        : CannyEdgeDetector.cpp
// Author      : Hannah Ervin
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <TooN/TooN.h>
#include <cvd/image_io.h>
#include <cvd/convolution.h>
#include <cvd/image.h>
#include <cvd/videodisplay.h>
#include <cvd/gl_helpers.h>
#include <cmath>
#include <iostream>


using namespace std;
using namespace CVD;
using namespace TooN;

void display_image(Image <byte>& im){
	VideoDisplay window(im.size());
	glDrawPixels(im);
	glFlush();
}

void sobel_filter(Image<byte>& in, Image<byte>& sobel, float scale, float *gradorientation, int gradwidth)
{
	ImageRef size = in.size();
	ImageRef border(1,1);
	ImageRef dx(1,0);
	ImageRef dy(0,1);
	ImageRef scan=border;
	do{
		double diffx = in[scan+dx]-in[scan-dx];
		double diffy = in[scan+dy]-in[scan-dy];
		sobel[scan] = scale*sqrt(diffx*diffx + diffy*diffy); //gradient magnitude
		if(diffx!=0){
			gradorientation[scan.x * gradwidth+scan.y] = atan(diffy/diffx);
			if(gradorientation[scan.x * gradwidth+scan.y]!=0){
				gradorientation[scan.x * gradwidth+scan.y] = gradorientation[scan.x * gradwidth+scan.y]*180.0/M_PI;
			}
		}
		else{
			gradorientation[scan.x * gradwidth+scan.y] = atan(diffy);
			if(gradorientation[scan.x * gradwidth+scan.y]!=0){
				gradorientation[scan.x * gradwidth+scan.y] = gradorientation[scan.x * gradwidth+scan.y]*180.0/M_PI;
			}
		}
		if(gradorientation[scan.x * gradwidth+scan.y]<-67.5){
			gradorientation[scan.x * gradwidth+scan.y] = 90;
		}
		else if (gradorientation[scan.x * gradwidth+scan.y] < -22.5){
			gradorientation[scan.x * gradwidth+scan.y] = 135;
		}
		else if(gradorientation[scan.x * gradwidth+scan.y]< 22.5){
			gradorientation[scan.x * gradwidth+scan.y] = 0;
		}
		else if(gradorientation[scan.x * gradwidth+scan.y]< 67.5){
			gradorientation[scan.x * gradwidth+scan.y] = 45;
		}
		else{
			gradorientation[scan.x * gradwidth+scan.y] = 90;
		}
		//cout<<gradorientation[scan.x * gradwidth+scan.y]<<endl;
	}
	while(scan.next(border, size-border));
}

void non_maxima_suppression(Image<byte>& sobel, float* gradorientation, int gradwidth, Image<byte>& out){
	ImageRef it(1,1);
	ImageRef size = sobel.size();
	ImageRef start(1,1);
	ImageRef east(1,0);
	ImageRef west(-1,0);
	ImageRef north(0,-1);
	ImageRef south(0,1);
	ImageRef southeast(1,1);
	ImageRef southwest(-1,1);
	ImageRef northeast(1,-1);
	ImageRef northwest(-1,-1);

	do{
		switch (gradorientation[it.x * (gradwidth+it.y)]){
		case 0:{
			out[it] = (sobel[it]>sobel[it+east])&&(sobel[it]>=sobel[it+west])?255:0;
		}
		case 45:{
			out[it] = (sobel[it]>sobel[it+northeast])&&(sobel[it]>=sobel[it+southwest])?255:0;
		}
		case 90:{
			out[it] = (sobel[it]>sobel[it+north])&&(sobel[it]>=sobel[it+south])?255:0;
		}
		case 135:{
			out[it] = (sobel[it]>sobel[it+northwest])&&(sobel[it]>=sobel[it+southeast])?255:0;
		}
		default:{

		}
		}
	}while(it.next(start, size-start));
}

int main()
{
	try{
		cout << "Hello World!" <<endl;
		//LOAD IMAGE
		string img_name("frog");
		Image<Rgb<byte> > im;
		im = img_load(img_name+".jpg");
		ImageRef size = im.size();

		//BLUR
		Image<Rgb<byte> > blurred(size);
		convolveGaussian(im, blurred, 5, 1.0);
		img_save(blurred, img_name+"gblur.jpg");

		//CREATE RED, GREEN and BLUE IMAGES
		Image<byte> red(size);
		Image<byte> green(size);
		Image<byte> blue(size);
		ImageRef it(1,1);
		ImageRef start(1,1);
		do{
			red[it] = blurred[it].red;
			green[it] = blurred[it].green;
			blue[it] = blurred[it].blue;
		}while(it.next(start, size-start));
		img_save(red, img_name+"red.jpg");
		img_save(green, img_name+"green.jpg");
		img_save(blue, img_name+"blue.jpg");



		//SOBEL FILTER
		Image<byte> redsobel(size);
		Image<byte> greensobel(size);
		Image<byte> bluesobel(size);
		float* gradorientation;
		int x = size.x;
		int y = size.y;
		gradorientation = new float[x*y];
		sobel_filter(red,redsobel, 1.0, gradorientation,x);
		sobel_filter(green,greensobel, 1.0, gradorientation,x);
		sobel_filter(blue,bluesobel, 1.0, gradorientation,x);
		img_save(redsobel, img_name+"greensobel.jpg");
		img_save(greensobel, img_name+"redsobel.jpg");
		img_save(bluesobel, img_name+"bluesobel.jpg");

		//COMBINE COLOUR CHANNELS
		Image<byte> combinedsobel(size);
		it.x = 1;
		it.y = 1;
		do{
			combinedsobel[it] = redsobel[it]+greensobel[it]+bluesobel[it];
		}while(it.next(start, size-start));
		img_save(combinedsobel, img_name+"combinedsobel.jpg");

		//NON MAXIMA SUPPRESSION
		Image<byte> combinedout(size);
		Image<byte> redout(size);
		Image<byte> greenout(size);
		Image<byte> blueout(size);
		non_maxima_suppression(combinedsobel,gradorientation, x, combinedout);
		non_maxima_suppression(redsobel,gradorientation, x, redout);
		non_maxima_suppression(greensobel,gradorientation, x, greenout);
		non_maxima_suppression(bluesobel, gradorientation, x, blueout);
		img_save(combinedout, img_name+"combinedout.jpg");
		img_save(redout, img_name+"redout.jpg");
		img_save(greenout, img_name+"greenout.jpg");
		img_save(blueout, img_name+"blueout.jpg");

		//DISPLAY RESULTS
		//display_image(im);
		//display_image(blurred);
		//display_image(sobel);
		cout<<"THE END"<<endl;

	}
	catch(Exceptions::All error){
	    std::cerr << "Error: " << error.what << std::endl;
	}

	return 0;

}
